\documentclass[sigconf,review,anonymous]{acmart}
%\usepackage{graphicx}
\let\algorithm\relax
\let\endalgorithm\relax
\usepackage[linesnumbered,ruled,vlined]{algorithm2e}%[ruled,vlined]{
%\usepackage{algpseudocode}
\usepackage{amsmath,amssymb}
\usepackage{framed}
\usepackage{booktabs}
\usepackage{subcaption}
\usepackage{multirow}
%\usepackage{multirow}
%\renewcommand{\algorithmicrequire}{\textbf{Input:}}  % Use Input in the format of Algorithm
%\renewcommand{\algorithmicensure}{\textbf{Output:}} % Use Output in the format
%\usepackage{xspace}{
%\usepackage[numbers, square, comma, sort&compress]{natbib}
%\usepackage[text size=small, backgroundcolor=blue!30,bordercolor=blue,linecolor=blue]{todonotes}
%\usepackage{graphicx}

%\newcommand{\myparagraph}[1]{\vspace{1.5ex}\noindent\emph{#1}\hspace{1.5ex}}
%\newtheorem{example}{Example}
%\newtheorem{definition}{Definition}
%\newtheorem{theorem}{Theorem}
%\newtheorem{problem}{Problem}
%\newtheorem{proposition}{Proposition}
%% correct bad hyphenation here
%\hyphenation{op-tical net-works semi-conduc-tor}

\acmConference[XXX'2018]{40th International Conference on Software Engineering}{May 27 - June 3}{Gothenburg, Sweden}
\acmYear{2018}
\copyrightyear{2018}

\begin{document}

\title{Follow the Money: Verifying Smart Contracts with Few False Positives}

\author{}
\affiliation{\institution{}}
\email{}

%\markboth{Journal of \LaTeX\ Class Files,~Vol.~14, No.~8, August~2015}%
%{Shell \MakeLowercase{\textit{et al.}}: Bare Demo of IEEEtran.cls for Computer Society Journals}

\begin{abstract}
In this work, we show how to identify vulnerabilities of Ethereum smart contracts through symbolic execution. The novelty is in reducing false alarms by following the money.
\end{abstract}

\maketitle

\section{Introduction}\label{sec:introduction}

\section{Motivating Examples}
In this section, we present multiple sample vulnerabilities which can be detected using our symbolic execution engine. For each sample, we show the smart contract code, explain how the attack is conducted, particularly, the trace that is executed during the attack and lastly how our engine identifies the attack.

\subsection{Sample 1}
The first sample contract is named \emph{Rubixi}\footnote{\url{https://github.com/gaobo89/Contract_code/blob/master/3TypesExamples/AddressPermute/rubixi.sol}}. The property which is violated by this contract is: \emph{the recipient of a money transaction should not be directly modifiable.}

\begin{figure}
	{\footnotesize
	\begin{verbatim}
1.	contract toyRubixi{
2.	    uint private collectedFees = 0;
3.	    address private creator;

4.	    function DynamicPyramid(){creator = msg.sender;}
        
5.      function collectFeesInEther(uint _amt) onlyowner payable{
6.                _amt *= 1 ether;
7.                if (_amt > collectedFees) _amt = collectedFees;
8.                if (collectedFees == 0) revert();
9.                creator.transfer(_amt);
10.                collectedFees -= _amt;
        }
    }
\end{verbatim}}
\caption{Example toyRubixi contract}
\label{sample1}
\end{figure}

At some point during the development of \emph{Rubixi}, its name was changed from \emph{DynamicPyramid} to \emph{Rubixi}. However, the authors forgot to change the name of the constructor accordingly. The constructor then became a function named  \emph{DynamicPyramid} which is invocable by anyone. Because function \emph{DynamicPyramid} updates the owner's address, which is used as the recipient of a ETH-transferring command in function \emph{collectFeesInEther}, an attacker is allowed to change the recipient arbitrarily and withdraw all money via function \emph{collectFeesInEther}. Shown in Figure 1.

For this vulnerability, the attack is composed of the following steps:

\begin{enumerate}
\item First, call function \emph{DynamicPyramid} in line 4 to change the creator to some malicious address.

\item Then, invoke the \emph{collectFeesInEther} function in line 5, if the amount collected is larger than the contract's \emph{collectedFees}, give all the \emph{collectedFees} to the amount.

\item Lastly, execute line 9 to transfer the ether to the malicious address. 
\end{enumerate}

%The following is a trace which is executed during the attack.

\subsection{Sample 2} The contract shows in Figure~\ref{sample2} (available at\footnote{\url{https://github.com/gaobo89/Contract_code/blob/master/3TypesExamples/UpperBound_DAO/toyDao.sol}}) allows a trace which violates the property \emph{there must be an upper bound on the transaction amount}. It is a simplified version of the TheDAO contract. The code is designed such that it is possible to repeatedly execute the ETH-transferring statement so that we can always find a trace sending more money than a given upper bound.

\begin{figure}
	{\footnotesize
	\begin{verbatim}
1.	contract toyDAO{
2.	    address owner;
3.	    address public participant;
4.	    uint public amout;
5.	    mapping (address => uint) credit;

6.	    function toyDAO() payable {
7.	        donate();		
        }
8.	    function donate() payable returns (bool){
9.	        participant = msg.sender;
10.	        amout = msg.value;
11.	        credit[msg.sender] += msg.value;
12.	        return true;
        }
13.	    function withdraw() {
14.	        if (!msg.sender.call.value(credit[msg.sender])()) {
15.       	        revert();
            }
16.	        credit[msg.sender] = 0;
        }
    }
\end{verbatim}}
\caption{Example toyDAO contract}
\label{sample2}
\end{figure}

\begin{figure}	
	{\footnotesize
	\begin{verbatim}
17.	contract MalloryAttack{
	    //DAO address is the attacked contract's address, here is
	    //0x8a0A8d81192264B0E436b57D30f472A6468780EF for test.
	
18.	    toyDAO public dao = toyDAO(DAO address);
19.	    address owner;

20.	    function MalloryAttack(){owner = msg.sender;}

        //this is where the attack starts
21.	    function MalloryCollect() payable {
22.	       dao.donate.value(msg.value)();
23.	       dao.withdraw();
           suicide(owner);
        }
	    //recursion here when call withdraw without credit decrease.
24.	    function() payable {
25.	       if(dao.balance > 0){
26.	           dao.withdraw();
           }
        }
    }	
	\end{verbatim} }
\caption{Attacking transaction}
\label{transaction2}
\end{figure}

An attack can be conducted using the transaction (written in the form of an Ethereum program named malloryAttack) shown in Figure~\ref{transaction2}. The attack is composed of the following steps.
\begin{enumerate}
\item At line 18, copy \emph{toyDAO} contract address to \emph{malloryAttack} and deploy the \emph{malloryAttack} contract with his own address.
\item Next, function \emph{MalloryCollect()} is invoked, which in turn calls function \emph{donate()} in contract \emph{toyDAO} at line 22. 
\item Next, function \emph{withdraw()} is invoked. 
\item Lastly, function \emph{suicide()} is invoked.
\end{enumerate}

The following presents the detailed execution of the attack when function \emph{MalloryCollect()} is invoked.
\begin{enumerate}
%    \item Malicious account2 execute function \texttt{MalloryCollect()} at line 136 with any ether(here we test with 2 ether) in the message.

    \item Execute line 22 to call function \emph{donate()} to increase the attacker's credit.

    \item Execute line 23 to call function \emph{withdraw()}.
    \item Execute line 14 which invokes function \emph{call()}.
    \item Because there is no mapping function, the fallback function at line 24 of \emph{malloryAttack} is invoked. 
    \item At line 25, if the balance is positive, function \emph{withdraw} is invoked again and the same steps are repeated. 
\end{enumerate}


\subsection{Sample 3} The following contract\footnote{The code is at~\url{https://github.com/gaobo89/Contract_code/blob/master/3TypesExamples/TransactionOrderDependance/ToyMmarketplace.sol}} violates the property \emph{there must be some non-zero reward for any work done}. The code is designed such that it is possible to set the reward to be zero and then get the work done for free. The code is shown in Figure 4.

\begin{figure}	
	{\footnotesize
	\begin{verbatim}
1.	contract Quiz{
2.	    address owner;
3.	    uint public reward = 2 ether;
4.	    uint public unsolved = 10;

5.	    function MarketPlace(){
6.	        owner = msg.sender;		
	    }
7.	    function updateReward(uint _reward){
8.	        if(msg.sender == owner)
9.	            reward = _reward;
	    }
10.	    function solve(string answer) payable returns (uint){
11.	        if(answer is false || unsolved <= 0) revert();
12.       	        unsolved --;
13.       	        msg.sender.send(reward);
	}   }   

	\end{verbatim} }
\caption{Example TOD disorder contract}
\label{Sample 3}
\end{figure}
	
The following presents the potential disputes of the contract.
\begin{enumerate}

    \item An honest participant calls the function \emph{solve} at line 10 with the correct answer, then send the transaction(we call it transactino1) to the Ethereum mining pool to wait the reward transferred back.

    \item The owner calls \emph{updateReward()} function to change the reward to 0 ether, send the transaction(we call it transaction2) to the Ethereum mining pool.

    \item If transaction2 is mined first, the honest participant will get nothing for reponsing this quiz.

\end{enumerate}

\subsection{Sample 4} The following\footnote{The code is at~\url{https://github.com/gaobo89/Contract_code/blob/master/3TypesExamples/TransactionOrderDependance/Etheramid.sol}} shows a contract which is claimed to be vulnerable using existing approaches, which turns out to be false positive.

\begin{figure}	
	{\footnotesize
	\begin{verbatim}
	
1.	function enter(address inviter) public {
2.	    uint amount = msg.value;
3.	    if ((amount < contribution) || (Tree[msg.sender].inviter != 0x0) 
            || (Tree[inviter].inviter == 0x0)) {
4.	        msg.sender.send(msg.value);
5.	        return;
	    }
6.	    addParticipant(msg.sender, inviter);
7.	    address next = inviter;
8.	    uint rest = amount;
9.	    uint level = 1;
10.	    while ( (next != top) && (level < 7) ){
11.	        uint toSend = rest/2;
12.	        next.send(toSend);
13.	        Tree[next].totalPayout += toSend;
14.	        rest -= toSend;
15.	        next = Tree[next].inviter;
16.	        level++;
	    }
17.	    next.send(rest);
18.	    Tree[next].totalPayout += rest;
	}
	
	\end{verbatim} }
\caption{Example TOD normal contract}
\label{Sample 4}
\end{figure}

Function \emph{enter} in Figure 5 is a snippet from Etheramid, it is claimed by Oyente as a TOD case, but the order of their execution does not change the outcome of the contract. The following presents the reason.

\begin{enumerate}
    \item The \emph{msg.sender.send} function in line 4 is identified by oyente as an ether flow, it returns Ether to the sender if some condition is not met.

    \item The \emph{next.send} function in line 12 and line 17 are identified as another ether flow, it pays out to the previous participants. 

    \item Whether the transaction of item1 succeeds or fails doesn't affect the transaction of item2, in wich the recipients and the amount are certain.

\end{enumerate}

\bibliographystyle{plain}
\bibliography{references}
\end{document}
